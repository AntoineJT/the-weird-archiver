use std::fs::File;
use std::io::{Read, Write};
use std::env;
use std::process::exit;

// TODO Avoid to use unwrap everywhere, do proper error handling
fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() == 1 {
        eprintln!("Error: no input file specified!
Format: {} <input_files...>", args[0]);
        exit(1);
    }
    let files = &args[1..]; // Ignore executable name from args
    let files = Vec::from(files);
    let batch = generate_batch(files);
    write_whole_file("output.bat", batch);
}

fn read_whole_file(filename: &str) -> Vec<u8> {
    let mut input = File::open(filename)
        .expect(format!("No {} file found!", filename).as_str());
    let mut buffer: Vec<u8> = Vec::new();
    input.read_to_end(&mut buffer)
        .expect("An error occured during original file reading");
    buffer
}

fn write_whole_file(filename: &str, content: String) {
    let mut file = File::create(filename).unwrap();
    file.write_all(content.as_bytes()).unwrap();
}

// I know base64 + hex is a good way to do the opposite of file compression, I will work on it later
// For now, I just want something fun to work with, to be used as a PoC
// TODO Find a way to do it for "large" files (which means like 4MB long) without "not enough memory" error
fn generate_batch(files: Vec<String>) -> String {
    let mut batch = String::new();
    batch.push_str("@echo off
rem This file has been generated by the-weird-archiver: https://github.com/AntoineJT/the-weird-archiver
\n");
    for file in files {
        let input = read_whole_file(file.as_str());
        let hex = hex::encode(input).to_ascii_uppercase();

        // TODO Can check if file exists before, in order to print an error message
        let hex_extract = format!("echo {} > {}.{}", hex, file, "hex"); // Writes hex to a file
        let extract_file = format!("certutil -decodehex {}.hex {}", file, file); // Decodes hex
        let rm_hex_file = format!("del {}.hex", file); // Deletes temporary hex file

        batch.push_str(format!("rem extract {}
{}\n{}\n{}\n\n", file, hex_extract, extract_file, rm_hex_file).as_str());
    }
    batch
}
